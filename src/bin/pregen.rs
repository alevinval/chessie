use std::{env, fmt::Write, fs};

use chessie::{
    bits,
    defs::{BitBoard, Sq},
    magic::Masks,
    pos,
    util::print_bitboard,
};

#[must_use]
#[allow(clippy::cast_possible_truncation)]
pub fn king() -> [BitBoard; 64] {
    let mut sq_to_moves = [0; 64];
    for (sq, moves) in sq_to_moves.iter_mut().enumerate() {
        let from = sq as Sq;
        let seed = pos::bb(from);
        let mut pattern = bits::north(seed)
            | bits::northwest(seed)
            | bits::northeast(seed)
            | bits::south(seed)
            | bits::southwest(seed)
            | bits::southeast(seed)
            | bits::west(seed)
            | bits::east(seed);

        if pos::col(from) == 0 {
            pattern &= Masks::NOT_FILE_H;
        } else if pos::col(from) == 7 {
            pattern &= Masks::NOT_FILE_A;
        }
        *moves = pattern;
    }
    sq_to_moves
}

#[must_use]
#[allow(clippy::cast_possible_truncation)]
pub fn knight() -> [BitBoard; 64] {
    let mut sq_to_moves = [0; 64];
    for (sq, moves) in sq_to_moves.iter_mut().enumerate() {
        let from = sq as Sq;
        let seed = pos::bb(from);

        let mut pattern = bits::northwest(bits::north(seed))
            | bits::northwest(bits::west(seed))
            | bits::southwest(bits::west(seed))
            | bits::southwest(bits::south(seed))
            | bits::northeast(bits::north(seed))
            | bits::northeast(bits::east(seed))
            | bits::southeast(bits::east(seed))
            | bits::southeast(bits::south(seed));

        if pos::col(from) < 2 {
            pattern &= Masks::NOT_FILE_H & bits::west(Masks::NOT_FILE_H);
        } else if pos::col(from) > 5 {
            pattern &= Masks::NOT_FILE_A & bits::east(Masks::NOT_FILE_A);
        }

        *moves = pattern;
    }
    sq_to_moves
}

#[must_use]
pub fn row_slider() -> [BitBoard; 8] {
    let mut sq_to_moves: [BitBoard; 8] = [0; 8];
    for (sq, moves) in sq_to_moves.iter_mut().enumerate() {
        let mut v = 1 << (sq * 8);
        for _ in 0..7 {
            v |= v << 1;
        }
        *moves = v;
    }

    sq_to_moves
}

#[must_use]
pub fn col_slider() -> [BitBoard; 8] {
    let mut sq_to_moves: [BitBoard; 8] = [0; 8];
    for (sq, moves) in sq_to_moves.iter_mut().enumerate() {
        let mut v = 1 << sq;
        for _ in 0..7 {
            v |= v << 8;
        }
        *moves = v;
    }

    sq_to_moves
}

#[must_use]
#[allow(clippy::cast_possible_truncation)]
pub fn diag_slider() -> [BitBoard; 64] {
    let mut sq_to_moves: [BitBoard; 64] = [0; 64];
    for (sq, moves) in sq_to_moves.iter_mut().enumerate().rev() {
        let p = sq as Sq;
        let o = 1 << sq;

        let mut v = 0;
        for (s, _) in (pos::col(p)..8).enumerate() {
            v |= o << (8 * s + s);
        }

        for (s, _) in (0..=pos::col(p)).enumerate() {
            v |= o >> (8 * s + s);
        }
        *moves = v;
    }

    sq_to_moves
}

#[must_use]
#[allow(clippy::cast_possible_truncation)]
pub fn antidiag_slider() -> [BitBoard; 64] {
    let mut sq_to_moves: [BitBoard; 64] = [0; 64];
    for (sq, moves) in sq_to_moves.iter_mut().enumerate().rev() {
        let p = sq as Sq;
        let o = 1 << sq;

        let mut v = 0;
        for (s, _) in (0..=pos::col(p)).enumerate() {
            v |= o << (8 * s - s);
        }

        for (s, _) in (pos::col(p)..8).enumerate() {
            v |= o >> (8 * s - s);
        }
        *moves = v;
    }

    sq_to_moves
}

fn emit_file() {
    let content = format!(
        "/// DO NOT EDIT THIS FILE MANUALLY
/// This file is auto-generated by `cargo run --bin chessie-pregen` (or `make pregen`)
///
/// Provides arrays where each entry corresponds to the movements of the piece on that square.
/// Movements are mashed up in a single BitBoard.

use crate::defs::BitBoard;

pub struct MagicMovements;


impl MagicMovements {{
 {king}
 {knight_moves}
 {row_slider}
 {col_slider}
 {diag_slider}
 {antidiag_slider}
}}
",
        king = emit_const("king_moves", &king()),
        knight_moves = emit_const("knight_moves", &knight()),
        row_slider = emit_const("row_slider", &row_slider()),
        col_slider = emit_const("col_slider", &col_slider()),
        diag_slider = emit_const("diag_slider", &diag_slider()),
        antidiag_slider = emit_const("antidiag_slider", &antidiag_slider()),
    );

    fs::write("src/magic/magic_movements.rs", content).unwrap();
}

fn emit_const(name: &str, values: &[u64]) -> String {
    let mut out =
        format!("pub(crate) const {}: [BitBoard; {}] = [\n", name.to_uppercase(), values.len());

    for value in values {
        writeln!(&mut out, "  0x{value:x},").unwrap();
    }
    writeln!(&mut out, "];").unwrap();
    out
}

fn print_bitboards(bbs: &[BitBoard]) {
    for bb in bbs {
        print_bitboard(*bb)
    }
}

fn main() {
    let args: Vec<String> = env::args().collect();
    match args.len() {
        1 => emit_file(),
        2 => {
            let cmd = args[1].as_str();
            match cmd {
                "print-king" => print_bitboards(&king()),
                "print-knight" => print_bitboards(&knight()),
                "print-row-slider" => print_bitboards(&row_slider()),
                "print-col-slider" => print_bitboards(&col_slider()),
                "print-diag-slider" => print_bitboards(&diag_slider()),
                "print-antidiag-slider" => print_bitboards(&antidiag_slider()),
                _ => println!("unrecognized argument"),
            }
        }
        _ => println!("unrecognized argument"),
    }
}
